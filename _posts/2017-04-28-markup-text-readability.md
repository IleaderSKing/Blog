---
layout: post
title: "数据结构与算法（笔记）"
excerpt: "时间复杂度"
categories:
  - 数据结构与算法
tags:
  - 数据结构与算法
  - c
---

#### 数据结构：
- **定义：**

       一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。
       
- **分类：**

	  逻辑结构：
	  - 定义：
		    - 数据对象中数据元素之间的相互关系。
      - 种类：
	        - 集合结构
	        - 线性结构
		    - 树型结构
		    - 网络结构
			    
	物理结构：
	- 定义：
          - 数据的逻辑结构在计算机的存储形式。

#### 算法：
- 定义：

	  指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。

- **特征：**
	  - 输入项
	  - 输出项
	  - 有穷性
	  - 确定性
	  - 可行性
	  
- **设计要求：**
	  - 正确性
	  - 可读性
	  - 健壮性
	  - 时间复杂度
	  - 空间复杂度
	  
- **效率：**
	  - 度量方法：
		缺陷：事先编写好程序 
	  - 事前分析估计法：
	    策略、代码质量、输入规模、执行指令

#### 时间复杂度
- **定义：**
	  - 算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。这是一个关于代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。
	  
- **计算方法：**
	  - 在进行算法分析时。语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定数量级。算法的时间复杂度，也就是算法的时间度量记作：T(n) = O( f(n) )。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同。其中f(n)是问题规模n的某个函数。
      
      - 一般情况下，随着输入规模n增大，T(n)增长最慢的算法为最优算法。 

- **攻略：**
	  - 用常数1取代运行时间中的所有加法常数。
	  - 在修改后的运行次数函数中，只保留最高阶项。
	  - 如果最高项存在且不为1，则去除与这个项相乘的常数。
	  - 得到的最后结果就是大O阶。
	  
##### 举例：
- **常数阶**
		  

``` 
int sum = 0, n =100;

printf("This a test!");

printf("This a test too!");

sum = (1+n)*n/2;

//时间复杂度为：O(1)
```


- **线性阶**
  - 一般含有非嵌套循环涉及线性阶，线性阶就是随问题规模n的矿大，对应计算次数呈直线增长。

``` 
int i, n = 100, sum = 0;

for(i = 0; i < n; i++){

sum = sum + i;

}

//时间复杂度为：O(n)
```
- **平方阶**

``` 
int i, j, n = 100;

for(i = 0; i < n; i++){
	
	for(j = 0; j < n; j++){
		printf("This a second test!");		
	}
}

//时间复杂度为：O(n^ 2)
```
	- 理解：
	
	   n 等于 100 时,即外层循环每执行一次，内层循环就执行 100 次，从程序退出来，需要执行 100*100 次，即 n^2 所以这段代码的时间复杂度为O(n^ 2)。
	   
	- 总结：
	  
	  循环的时间复杂度等于循环体的复杂度乘以该循环运行次数。

``` 
int i, j, n = 100;

for( i = 0; i < n; i++){

	for( j = i; j < n; j++){
		
		printf("This a third test!");
		
	}
}

//时间复杂度为：O(n^ 2)
```
	- 分析：
	
	  当 i = 0 时，内循环执行 n 次，当 i = 1 时，内循环执行 n - 1 次......当 i = n -1 时，内循环执行 1 次，总的执行次数为：
	  - n + (n -1) + (n -2) + (n -3) + (n -4) +......+1 = n*(n + 1)/2
	  
- **对数阶**

``` 
int i = 1, n = 100;

while(i < n){
	
	i = i * 2;
}

//时间复杂度为：O(log n )
```
    - 分析：
	   由于每次 i * 2 之后，距离 n 更近一步，假设有 x 个 2 相乘大于或等于 n 则退出循环
	   2 ^ x = n
	   x = log2^n

 
 - **函数调用时间复杂度**

``` 
int i, j;

for( i = 0; i < n; i++ ){

function(i);
}

void function(int count){

printf("%d",count);
}

//function函数的时间复杂度为：O(1)
//整体的时间复杂度为：O(n)

//假设：
void function(int count){

	int j;

	for( j = count; j < n; j++){
		printf("%d",j);
	}
}

//时间复杂度为：O(n ^ 2)
```
#### 常见时间复杂度：
```
| 表达式         |    时间复杂度 |  类型    |
| :--           |    :--      |  :--    |
| 2017428       |    O(1)     | 常数阶   |
| 3n+4          |    O(n)     | 线性阶   |
| 3n^2+4n+5     |    O(n^2)   | 平方阶   |
| 3log2^n + 4   |    O(logn)  | 对数阶   |
| 2n+2n^2+4n+6  |    O(nlogn) | nlogn阶 |
| n^3+2n^2+4n+6 |    O(n^3)   | 立方阶   |
| 2^n           |    O(2^n)   | 指数阶   |
```
 - 常用时间复杂度所消耗的时间从小到大排序：
 
   **O(1)** < **O(logn)**<**O(n)**<**O(nlogn)**<**O(n^2)**<**O(n3)**<**O(2^n)**<**O(n!)**<**O(n^n)**
